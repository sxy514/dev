Constructors.java是 构造函数的 示例
 在构造函数示例中了解到 构造函数是用来初始化对象的特殊方法
 在创建类的对象时调用构造函数。它可以用来设置对象属性的初始值:
 注意，构造函数名必须与类名匹配，并且不能有返回类型(如void)。
默认情况下，所有类都有构造函数:如果您自己不创建类构造函数,Java会为您创建一个,但是这样就不能为对象属性设置初始值了


Modifiers.java 都是 修饰符的 示例
 在修饰符示例中了解到 修饰符被分为两组，访问修饰符与非访问修饰符
 //访问修饰符：控制访问级别
 // 对于类，访问修饰符 可使用 public 或 默认不写
 public 修饰符表示 该类可以被 任何其他类访问；
 默认不写 表示 该类只能被同一个包中的类访问；
 // 对于属性，方法和构造函数：.
 public : 所有类都可以访问到该代码；
 private ：代码只能在声明它的类中访问；
 protected ：代码可在相同的包或者子类中访问；
 默认不写 ：当你没有指定修饰符的情况下，代码只能被同一个包中访问；
 //非访问修饰符：不控制访问级别，提供其他功能
 // 对于类 可使用 final 和 abstract :
 final 表示 该类不能被继承；
 abstract 表示该类为抽象类，无法用于创建对象，只能被继承到子类中后才能访问其属性和方法；
 // 对于属性和方法使用：
 final:    属性和方法不能被修改/覆盖；
 static:   属性和方法属于类，而不是对象，可直接调用
 abstract: 只能在抽象类中使用,并且只能应用于方法,创建的抽象方法没有body,例如 abstract void run(); 方法的主体将由子类提供
 transient: 在序列化包含 transient 的属性和方法的对象时，将跳过它们
 synchronized: 方法一次只能有一个线程访问
volatile: 属性的值不是线程本地缓存的,总是从“main memory”读取


Obj1.java 是 创建类的对象的 示例
 在示例中了解到 用 Class 来创建 对象， 使用 new 关键字
 创建的对象将拥有类的属性和方法。
 例如： 类名 对象名 = new 类名();  // 创建类的对象
然后通过 . 来访问对象属性和方法


InnerClasses.java 是 内嵌类 的示例
 在Java中, 也可以嵌套类(类中类)。
 嵌套类的目的是将属于一起的类分组，从而使代码更具可读性和可维护性。
要访问内部类，创建一个外部类的对象，然后创建一个内部类的对象:


Abstract.java 是 抽象类 的示例： 
 抽象类的概念：抽象类无法创建对象，只能继承到子类中才能调用属性和方法， 
 在(abstract)抽象类中创建的抽象方法,主体在子类中提供。例如创建一个abstract方法: public abstract void animalSouud();
 为什么以及何时使用抽象类和方法?
 为了实现安全性-隐藏某些细节，只显示对象的重要细节。
注意:抽象也可以通过接口来实现，你将在下一章学到更多的知识。

Encapsulation.java 是 封装 的示例：
 封装的意义，是确保对用户隐藏“敏感”数据。要做到这一点，你必须:
 将类变量/属性声明为私有,提供公共get和set方法来访问和更新私有变量的值
 两者的语法都是以get或set开头,后面跟着变量名首字母大写:
在编写 公共set 方法时 需注意该语句的写法 , 在写 公共get 时该方法 return 需要获取的变量


PackageAPI.java 是导入 包/API 的示例
 在Java中的包用于将相关的类进行分组,将其视为在一个文件夹
 我们使用包来避免名称冲突，并编写更好的可维护代码
 包分为两类:
 // 内置包(来自Java API的包): 使用 API 用关键字 import
 Java API是一个预先编写的类库,可以免费使用,包含在Java开发环境中。
 该库包含用于管理输入、数据库编程等的组件。完整的列表可以在oracle网站上找到:https://docs.oracle.com/javase/8/docs/api/。
 库分为包和类。这意味着您可以导入单个类(及其方法和属性)，也可以导入包含属于指定包的所有类的整个包。
 导入单个类: import package.name.Class;   
 导入整个包: import package.name.*;   
 // 用户定义的包(创建自己的包): 使用 自定义包 用关键字 package
导入自定义包: package 文件路径；； 例如 package obj;


Inheritance.java 是 类继承 的示例
 可以让一个类的属性和方法继承到另一个类中，我们将继承类分为两类: 父类和子类
 父类：被继承类,将自身属性和方法继承给子类
 子类: 从父类继承属性和方法 , 使用 extends 关键字： class 子类名 extends 父类名;
继承可以提高代码的重用性，在创建新类时重用现有类的属性和方法;


Polymorphism.java 是 多态 的示例
 继承允许我们从另一个类继承属性和方法。
 多态性使用这些方法来执行不同的任务。这允许我们以不同的方式执行单个操作。
一个父类可以被多个子类继承


InnerClass.java 是 内部类 的示例
 在Java中，也可以嵌套类(类中类)。嵌套类的目的是将属于一起的类分组，从而使代码更具可读性和可维护性。
 要访问内部类，创建一个外部类的对象，然后创建一个内部类的对象:
// 外部类名.内部类名 对象名 = 外部对象名.new 内部对象名();


IInterface.java 是 接口(Interface) 的示例
 在Java中实现 抽象的另一种方法是 使用 接口(interface)
 使用 interface 关键字 是一个完全的“抽象类”，由 interface 声明的类，它的类方法不包含 body, 类方法的主体由 implementes 类中提供
 要访问 interface 类方法，必须使用 implementes 来实现 interface类 .接口不能直接创建对象，与继承概念相似，需实现后才能调用接口方法
 (就像是继承使用 extends 那样, interface 需要 implementes 来实现)
 // 接口关键字 interface 和 implements 实现
 // 在Java中不能多重继承,一个子类只能继承一个父类，而接口则可以多个实现,使用逗号分隔符
// 请注意不能在同一个Package里有多个class 里拥有同样名字的类，容易编译报错


Enums.java 是 枚举 的示例
 枚举是一个特殊的“类”，它代表一组常量(不可改变的变量,比如final变量)。
 要创建枚举,请使用enum关键字,并使用逗号分隔常量。注意，它们应该是大写字母:
 // 使用 . 访问枚举中的常量
 // 注意是如何访问枚举类中的常量的
 // Level myVar = Level.MEDIUM;语法为 枚举名 变量名 = 枚举名.常量名
 // 循环遍历枚举，枚举类型有一个方法 .values() 专门用于遍历enum
 // 语法为： for(枚举名 变量名 : 枚举名.values()) { 输出该变量 } 
 枚举和类之间的区别：   当你有一些你知道不会改变的值时使用枚举
枚举可以像类一样具有属性和方法。唯一的区别是枚举常量是公共的、静态的和final的(不可更改——不能被重写)。


jscanner.java 是 用户输入 的示例
 导入类 java.util.Scanner 该类用于获取用户输入
 Scanner myObj = new Scanner(System.in) 创建对象的写法 需要 new Scanner(System.in)
创建对象后调用方法 .nextLine() 可接收用户输入的字符串 , 要接收其他类型 把Line替换掉, 如 int a =  myObj.nextInt();

DateTime.java 是 日期和时间 的示例
 Java 没有内置的 Date 类，但我们可以导入包以使用日期和时间 API。该软件包包括许多日期和时间类
 DateTimeFormatter: 用于设置日期和时间的格式
 LocalDate: 表示日期(年、月、日(yyyy-MM-dd))
 LocalTime: 表示时间(小时，分钟，秒和纳秒)
LocalDateTime: 同时表示日期和时间(yyyy-MM-dd-HH-mm-ss-ns)


ArrayList1.java 是 一个可动态修改的数组列表  示例
 该类是一个可调整大小的数组，可以在包 java.util.ArrayList 中找到
 和普通数组的区别是它可以随时添加或删除数组元素，语法也不相同， 将元素存储为有序线性集合,通过索引号访问;
 ArrayList 中的元素实际上是对象。在上面的例子中，我们创建了元素 类型为“字符串”的（对象）。
请记,Java 中的字符串是一个对象（不是基元类型）。若要使用其他类型(如 int),必须指定等效的包装类: Integer Boolean Character Double

 
LinkedList(链表) 与 ArrayList 类似 是一种常用的数据容器
 链表(Linkedlist)是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的地址。
 与 ArrayList 相比,LinkedList 的增加和删除的操作效率更高，而查找和修改的操作效率较低。
 以下情况使用 ArrayList :
 频繁访问列表中的某一个元素。
 只需要在列表末尾进行添加和删除元素操作。
 以下情况使用 LinkedList :
 你需要通过循环迭代来访问列表中的某些元素。
 需要频繁的在列表开头、中间、末尾等位置进行添加和删除元素操作。

 HashMap.java 是 哈希map 的示例
 HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。是无序的，即不会记录插入的顺序。