一、面向对象技术
  面向对象技术是一种软件开发方法，在面向对象程序设计方法出现之前，软件界广泛流行的是面向过程的设计方法，这种方法中使用的众多变量名和函数名互不约束，令程序员不堪重负。
  随着开发系统规模的不断扩大，面向过程的方法越来越不能满足开发人员的要求，面向对象技术应运而生，这种新技术使得程序结构简单，相互协作容易，更重要的是程序的重用性大大提升。
  所谓面向对象的方法学，就是使得分析、设计和实现一个系统的方法尽可能地接近人们认识一个系统的方法。
  通常分为三个方面：面向对象的分析(OOA)、面向对象的设计(OOD)、面向对象的程序设计(OOP)。面向对象技术包含的概念主要有抽象、对象、类、类型层次(子类)、封装、继承性、多态性等。
  Java语言是一种“纯”面向对象语言，它的所有数据类型，包括最基本的布尔型、数值型及字符型，都有相应的类，程序可以完全基于对象来编写。
  
二、OOP
  现实世界中存在很多同类的对象，他们来自于同一种原型，具有一样的共性。或者说它们来自与同一个模板。这就是类的概念。这其中的某个特定实体即为实例或称对象。对象是类的具相，类是对象的抽象。
  OOP技术把问题看成是相互作用的事物的集合，也就是对象的集合。对象具有两个特性，一是状态，二是行为。状态是指对象本身的信息，行为是实现对对象的操作。在OOP中，用属性来描述状态，而把对它的操作定义为方法。-->
  --> 属性也称为数据，这样的对象就是数据加方法。可以将现实生活中的对象经过抽象、映射为程序中的对象，
  OOP中采用了三大技术：封装、继承和多态。封装体现的特点是将对象的属性及实现细节隐藏起来，只给出如何使用的信息。
  1.封装：将数据及对数据的操作捆绑在一起成为类，这就是封装技术。对象是类的实例，外界使用对象中的数据收到类定义的限制
  2.继承：将一个已有类中的数据和方法保留，并加上自己特殊的数据和方法，从而构成一个新类，这是OOP中的继承。原来的类是父类，也称为基类或超类。新类是子类，子类派生与父类，或说子类继承父类。继承体现的是一种层次关系，下一层的类可以从上一层的类继承定义，同时还可以改变和扩充一些特性
  3.多态：在一个类或多个类中，可以让多个方法使用同一个名字，从而形成多态性。多态可以保证对不同类型的数据进行等同的操作，名字空间也更加宽松。多态还有一个重要的特点，即使用相同的操作名，能根据具体的对象自动选择对应的操作。
  
  
第二章第一节：
一、空白，注释及语句
  1.空白：在Java程序中，换行符和回车符都可以表示一行的结束，它们可以被看作空白。应该注意代码的格式，增加可阅读性
  2.注释：程序中适当的加入注释可以增加易读性，注释有三种形式：1.// 在一行内的注释  2./* 一行或者多行注释 */  3./** 文档注释 */ 
  3.语句、分号和块：语句是Java程序的最小执行单位，程序的各语句间以“;” 分隔。在 “{}” 内的一系列语句成为语句块。

二、关键字
  Java语言定义了许多关键字，关键字也称为保留字。它们都有各自的特殊意义和用途，不能把它们当成普通的标识符使用。
  Java关键字如下：
  abstract	 boolean    break	 byte	case 	cast	catch	char	class	const	continue	default		do 		double		else  	extends		false	 final	 finally	float	for
  future	generic		goto	 if		implements		import		innner		instanceof	  int		interface		long 	native		new		null	 operator	outer	 package	private		
  protected	 public		rest	return	short	static	strictfp	super		switch		synchronized(线程同步)	 this		throw	 throws		transient	 true	try		var		void  	volatile	while
  定义的这些关键字中，少数几个已不再使用。还有几个是预留的关键字，目前尚未使用。这些关键字是：cast, const, future, generic, goto, inner, operator, outer, rest和var等
 
三、标识符
  在Java中，标识符由字母、数字、下划线(_)或美元符号（$）组成的字符串，其中数字不能作为标识符的开头。标识符区分大小写，长度没有限制。除以上所列几项外，标识符中不能含有其他符号，当然也不许留空白，在程序中，标识符可用作变量名，方法名、接口名和类名等。
  Java源代码使用的是unicode码，而不是ASCII码

四、Java编程风格
  在编程时，应当注意自己的编程风格，增加必要的注释和空格，采用缩进格式。
  以下是常见的命名约定：
  1.类名或接口名：多为动词，含有大小写，首字母大写，其余各单词首字母大写。如HelloWorld..
  2.方法名：多是动词，含有大小写，首字母小写，其余各单词首字母大写，尽量不要在方法名中使用下划线。如getName\setAdress等
  3.常量名：简单类型常量的名字应该全部为大写字母，单词与单词之间用下划线分隔，对象常量可以使用混合大小写，如BLUE_COLOR。
  4.变量名：所有的实例变量，类变量，终极变量和静态变量等都使用混合大小写，首字符为小写，后面单词的首字母用大写。变量名中尽量不要使用下划线。如balance, orders等
  命名名称要有意义，尽量避免使用单字符名字，除非是临时使用的要“扔掉”的变量（比如在循环结构中的循环变量），总的来说就是要增加代码的可读性
 
第二节、基本数据类型
  Java的数据类型共分为两大类，一类是基本数据类型，另一类是复合数据类型。基本类型有八种，分为4小类，分别是整型，浮点型，字符型，和布尔型。整型和浮点型也合称为数值型。复合数据类型包括数组，类和接口。其中，数组也是一个很特殊的概念，它是对象，而不是一个类，一般把它归为复合数据类型。
  1.Java语言提供了4种整型量，对应的关键字分别是：byte, short, int 和 long。 它们的字节大小和可表示的范围分别是：
  byte(整数长度8位,字节数1)= -2的7次幂 ～ 2的7次幂-1 (-128~127)
  short(整数长度16位，字节数2)= -2的15次幂 ～ 2的15次幂-1（-32768～32767）
  int(整数长度32位，字节数4)= -2的31次幂 ～ 2的31次幂-1（-2,147,483,648～2,147,483,647）
  long(整数长度64位，字节数8)= -2的63次幂 ～ 2的63次幂-1（-9,223,372,036,854,775,808～9,223,372,036,854,775,807）
  整型常量是int型的。如果想表示一个长整型常量，需要在数的后面明确写出字母“L”。L表示它是一个long型量。这里，使用大写L或者小写l均有效。Java语言还提供了几个特殊的整型常量值表示最大值和最小值（比如int类型最大值为: integer.MAX_VALUE;最小是为integer.MIN_VALUE）
 
  2.Java浮点数类型遵从标准的浮点规则。浮点数类型有两种：一种是单精度浮点数，用float关键字说明;另一种是双精度浮点数，用double关键字说明，它们都是有符号数。
  float(浮点数长度32位，字节数4)= 1.4e-45f ~ 3.4028235e + 38f
  double(浮点数长度64位，字节数8)= 4.9e-324d~1.7976931348623157e + 308d
  如果数值常量中包含小数点，指数部分（字符E），或数的后面跟有字母F或字母D，则为浮点数。浮点数常量在默认情况下是double型的，除非用字母F明确说明它是float型。浮点型常量中的字母D或者F支持大小写。
  Java语言中有几个特殊的浮点数常量：float/double类型通用（最大值：Float.MAX_VALUE; 最小值：Float.MIN_VAlUE; 正无穷大：Float.POSITIVE_INFINITY; 负无穷大：Float.NEGATIVE_INFINITY; 0/0: Float.NaN;）
 
  3.字符类型char：单个字符用char类型表示。一个char表示一个Unicode字符，其值用16位无符号整数表示，范围为0～65535。char类型的常量值必须用一对单引号('')扩起来，分为普通字符常量和转义字符常量两种。
  使用单引号括住一个字符，表示一个普通的字符常量。但有些字符在Java语言中有特殊含义，常用转义符： \b表示退格键 \n表示换行符 \r表示回车符 \t表示水平制表符 \\表示一个反斜杠 \'表示一个单引号 \"表示一个双引号
  
  4.布尔类型boolean：逻辑值有两种状态，它们常被写作on和off，true和false，yes和no等。布尔类型也称为逻辑类型。bool类型有两个常量值：true和false，它们全是小写，在计算机内部用8位二进制数表示。
  Java是一种严格的类型语言，它不允许数值类型和布尔类型之间进行转换。不能向C/C++那样允许用数值表示逻辑值，如用0表示false，非0表示true。Java不允许这样做，需要使用逻辑值的地方不能以其他类型的值替代

第三节、表达式
  表达式由运算符和操作数组成，对操作数进行运算符指定的操作，并得出运算结果;
  Java运算符按功能可分为：算术运算符/ 关系运算符/ 逻辑运算符/ 位运算符/ 赋值运算符/ 条件运算符，除此之外，还有几个特殊用途的运符，如数组下标运算符等。操作数可以是变量，常量或方法调用等
  1.操作数：有常量和变量之分，只有简单数据类型和String类型才有相应的常量形式，变量是存储数据的基本单元，它可以用作表达式中的操作数，变量在使用之前要先声明。
  有时把类类型的变量称为引用。在声明变量的同时给变量赋了初值，称为对变量进行了初始化。 声明变量的地方有两处，一处是在方法内，另一处是在类定义内。方法内定义的变量称为自动变量，也称为局部变量、临时变量或栈变量。类中定义的变量是类的成员变量。
  Java程序中不允许将未经初始化的变量用作操作数。
  变量作用域：变量的作用域是值可访问该变量的代码范围。类中定义的成员变量的作用域是整个类。方法中定义的的局部变量的作用域是从该变量的声明处开始到包含该声明的语句块结束处，块外是不可用的。
  
  2.运算符
  2.1 算术运算符：算术运算符包括通常的加(+)、减(-)、乘(*)、除(/)、取模(%),完成整型和浮点型数据的运算。许多语言中的取模运算符只能用于整型数据，Java对此有所拓展，它允许对浮点数进行取模操作，例如 15.2 % 5 的结果是 0.2，取模还可以用于负数，结果的符号与地一个操作数符号相同。
  此外，算术运算符还有“++”和“--”自增和自减运算符，这两个运算符有前缀形式和后缀形式，++i和i++的执行顺序不一样，++i在i使用之前先加1,i++在i使用过后再加1,--i和i--的情况与此类似。
  
  2.2 关系运算符：关系运算符用来比较两个值，包括大于(>)、小于(<)、大于等于(>=)、小于等于(<=)、等于(==)和不等于(!=)6种。关系运算符都是二元运算符，也就是每个运算符都带有两个操作数。运算的结果是一个逻辑值。
  Java允许“==”和“！=”两种运算用于任何数据类型。例如，可以判断两个实例是否相等。
  
  2.3 逻辑运算符：逻辑运算符包括逻辑与(&&)、逻辑或(||)、逻辑非(!)。前两个是二元运算符，后一个是一元运算符。
  
  2.4 位运算符：位运算符用来对二进制位进行操作，包括按位取反(~)、按位与(&)、按位或(|)、异或(^)、右移(>>)、左移(<<)、及无符号右移(>>>)。位运算符只能对整型和字符型数据进行操作。运算在八位二进制下进行。
  Java提供两种右移运算符。运算符“>>”执行算术右移，它使用最高位填充移位后左侧的空位。右移的结果为：每移一位，第一个操作数被2整除一次，移动的次数由第二个操作数确定。
  逻辑右移运算符(也称为无符号右移运算符) >>>只对位进行操作，而没有算术含义，它用0填充左侧的空位。算术右移不改变原数的符号，而逻辑右移不能保证这一点。
  
  2.5 其他运算符：Java中的运算符还包括拓展赋值运算符(+=、-=、*=、/=、%=、&=、|=、^=、>>=、<<=和>>>=）、条件运算符(?:)、点运算符(.)、实例运算符(instan-ceof)、new运算符及数组下标运算符([])等。
  条件运算符(?：)是三元运算符，它的一般形式为：逻辑表达式 ? 语句1：语句2;  其中逻辑表达式得到一个逻辑值，根据该值的真假决定执行后续操作。逻辑值为真执行语句12,否则执行语句2。语句1和语句2需返回相同类型的值，且不能为void。
  
  2.6运算符的优先次序：在对一个表达式进行运算时，如果表达式中含有多种运算符，则要按运算符的优先次序依次从高到低进行，同级别的运算符则根据结合律自左向右或自右向左进行。括号可以改变运算次序。
  
  3.表达式的提升和转换：
  Java是一种强类型语言，不支持变量类型间的自动任意转换，有时必须显式地进行变量类型的转换。不同类型的数据先转换为同类型然后再进行运算。转换的一般原则是位数少的类型转换为位数多的类型，这称为自动类型转换。这样做的目的是保证转换时不丢失有用信息。
  能够进行自动类型转换的类型顺序为：byte、short、char、int、long、float、double。排在前面的类型可自动转换为排在后面的类型
第二章小结：本章介绍了Java程序的一些基本语法知识，包括空白、注释、关键词及标识符、数据和表达式等。着重介绍了Java语言命名标识符规则，列出了所有的关键字。介绍了8种基本数据类型，包括表示它们的关键字，各类型的表示范围，各类型常量值的含义、转义符的含义等。
本章还介绍了运算符的含义及其优先级，变量的声明、初始化、赋值方法及其作用域、Java表达式的表示方法、表达式提升和转换方法也是本章的重点。
   
   
第三章 流程控制语句：
第一节、Java程序的结构：
  一个Java程序可以由一个或多个.java文件组成，这些文件称为源文件。每个源文件中含有一个或多个类或接口。一个源文件中如果有多个类，则最多只能有一个是public类型的类，且该源文件的名字则为这个公有类的名字，且大小写一致。其他非public的类的个数不限。
  一个Java程序的结构包含以下内容：
   package语句：  包语句，每个文件最多只有一个，且必须放在文件开始的地方。
   import语句：  引入语句，可以没有，也可以有多个，如果有import语句的话，必须放在所有类定义的前面。
   具有public权限的类定义：  每个文件中最多有一个。
   类定义：  每个文件中包含的非public权限的类定义的个数没有限制。
   接口定义：  每个文件中包含的接口定义个数没有限制
  
  1.1 Java包的概念
  包是类的容器，包的设计人员利用包来划分名字空间，以避免类名冲突。Java中的包一般均包含相关的类，使用包的目的就是将相关的源代码文件组织到一起。
  程序中如果有package语句，该语句一定是源文件中的第一条非注释语句，它的前面只能有注释或空行。另外，一个文件中最多只能有一条package语句。包的名字有层次关系，各层之间以点分隔。
  
  1.2 引入语句
  假设已定义如下的包：
  package mypackage;
  public class MyClass {....}
  如果其他人在其他包中想使用MyClass类，则需要使用全名，如： mypackage.MyClass m = new mypackage.MyClass();
  为了简化程序的书写，Java提供了引入语句。当需要使用其他包中的类时，可以使用import语句引入需要的类，程序中无需在使用全名，语句简写为：import mypackage. *; MyClass m = new MyClass();
  从系统的角度来看，包名也是类名的一部分。包中类的名字“全称”是包名加类名。所以虽然不同的包中可能存在相同名称的类，但因为它们不在同一个包中，故类名还是不同的，从而可以尽最大可能避免名称冲突。从另一个角度看，这种机制提供了包一级的封装及存取权限。
  
第二节、流程控制
  Java程序中的语句指示计算机完成某些操作，一条语句的操作完成后会把控制转给另一条语句。语句是Java的最小执行单位，语句间以分号(;)作为分隔符。语句分为单语句及复合语句，单语句就是通常意义下的一条语句;而复合语句是一对大括号{}括起来的语句组，也称为“块”。
  2.1.赋值语句
  在Java程序中，表达式可以当作一个值赋给某个变量，这样的语句称为赋值语句。有的表达式也可单独当作语句，这样的语句称为表达式语句。	
  
  2.2 分支语句
  分支语句根据一定的条件，动态决定程序的流程方向，从程序的多个分支中选择一个或几个来执行。分支语句有if语句和switch语句两种。
  if语句：if语句是单重选择，最多只有两个分支。基本格式为： if(条件表达式) {语句1;} else {语句2;} 
  if关键字之后的条件表达式必须得到一个逻辑值，不能向其他语言那样用数值来代替。因为Java不提供数值与逻辑值之间的转换。
  if语句的三种常见形式：形式1，没有else子句。形式2,包含else语句。形式3,嵌套的if语句。
  
  switch语句：使用if语句可以实现简单的分支判断，并进而执行不同的语句。为了更方便地实现多重分支，Java语言还提供了switch语句，它的含义与嵌套if语句类似，只是格式上更加简洁。语法格式如下：
  switch (表达式) {
  		case c1：
  			语句组1;
  			break;
  		case c2：
  			语句组2;
  			break;
  } 这里，表达式的计算结果必须是int或char型，即是int型赋值相容的。当用byte或者short型时，要进行提升。Java规定switch语句不允许使用浮点型或long型表达式。c1，c2是int型或字符串型常量。default子句是可选的，
  switch语句的语义是：计算表达式的值，用该值依次和c1,c2相比较。如果该值等于其中之一则执行后面的语句组，直到遇到break语句跳到switch之后的语句。如果没有相匹配的case，则执行default之后的语句组。
  可以将default语句看作一个分支，即前面的条件均不满足时执行default。
  
  3.循环语句
  循环语句控制程序流多次执行一段代码。Java语言提供3种循环语句，分别是for语句、while语句和do语句。
  3.1 for(初始语句;条件表达式;迭代语句){
  		循环体语句;
  } //初始语句和迭代语句中可以包含有多个语句，各语句间以逗号分隔。for语句括号内的3个部分都是可选的，条件表达式为空时，默认规定为恒真。
  for语句的语义是：先执行初始语句，判断条件表达式的值，当条件表达式为真时，执行循环体语句，再执行迭代语句，然后去判别条件表达式的值。这个过程一直进行下去，知道条件表达式的值为假时，循环结束，转到for之后的语句继续执行。
  如果条件表达式的值永远为真，则循环会无限制的执行下去，直到系统资源消耗尽为止。比如for(;;){System.out.println("Always print!");}
  
  3.2 while语句：
  for语句中常常用循环控制变量显式控制循环的执行次数。当程序中不能明确地指明循环的执行次数时，可以仅用条件表达式来决定循环的执行与否。这样的循环用while来实现：
  while(条件表达式)：
    循环体语句;
  和if语句一样，while语句中的条件表达式亦不可用数值来代替。
  while语句的语义：计算条件表达式的值，当值为真时，重复执行循环体语句，直到条件表达式为假时结束。如果第一次检查时条件表达式为假，则循环体语句一次也不执行。如果条件表达式始终为真，则循环不会终止。
  
  3.3 do语句：
  do语句与while语句很相似。它把while语句中的条件表达式移到循环体之后。
  do语句的语法结构：
  	do：
  		语句：
  	while(条件表达式);
  do语句的语义是:首先执行循环体语句，然后判断条件表达式的值，当值为真时，重复执行循环体语句，直到表达式的值为假时结束循环。不论条件表达式的值是真是假，do循环中的循环体至少执行一次。
  
  4.跳转语句：
  	Java抛弃了有争议的goto语句，代之以两条特殊的流控制语句：break和continue语句，它们用在分支语句或循环语句中，更方便的控制程序执行的方向。
  4.1 标号：
  标号可以放在任意语句之前，通常与for、while或do语句配合使用，其语法格式为：
  标号：语句;
  
  4.2 break语句：
  break语句可用于3类语句中，第一类是在switch语句中，第二类实在for、while及do等循环语句中，第三类是在语句块中。在switch语句及循环语句中，break的语义是跳过本块中余下的所有语句，转到快尾，执行其后的语句。
  循环语句中的break为跳过余下的语句，结束循环。break语句的第三种使用方法是在块中和标号配合使用，其语法格式为：
  int x = 20;
  out: for(;;) {
  		if(x == 20) break out;
  }
  System.out.println("after out block");
  在上述案例中，当if语句条件满足时，跳出out标记的循环，执行块后的语句，即执行输出语句，显示“after out block”。
  
  4.3 continue语句：
  在循环语句中，continue语句可以立即结束当次循环，开始执行下一次循环，当然执行前需要先判断循环条件是否满足。
  continue语句也可以和标号一起使用，其语法格式为： continue 标号;
  它立即结束标号标记的那重循环的当次执行，开始下一次循环。这种形式的语句可以用在多重循环中。
 
第三节、简单的输入/输出
  程序运行期间交互式地读入用户的输入并将计算结果返回给用户是一个基本要求。本节介绍Java提供的用于输入/输出的几个基本类。
  1.Scanner类
  Scanner类属于Java.util包。它提供了许多方法，可用来方便地读入不同类型的输入值。可查阅相关的API文档来详细了解。
  要调用Scanner类的方法，必须先创建一个对象。Java中使用了new运算符来创建，语句如： Scannner scan = new Scanner(System.in);
  在创建Scanner类的对象时，构造方法接收一个参数，这个参数代表了输入源。System.in对象代表标准输入流，默认指键盘。
  Scanner对象用空白(空格，水平制表符及回车换行符)作为输入的分隔元素。这些空白成为分隔符。也可以指定用其他符号作为分隔符。
  Scanner类的next()方法读入下一个输入对象，将它作为字符串返回。如果输入的是一串用空白分开的多个字，则每次调用nex()都会得到下一个字。nextLine()方法读入当前行的所有输入，直到行尾，然后作为字符串返回。
  Scanner类的不同方法，如nextInt()和nextDouble()，用来读入不同类型的数据。输入的数值类型必须与所声明的变量类型要赋值兼容。
  
  2.NumberFormat类和DecimalFormat类
  NumberFormat类提供对数值进行格式化操作的一般功能。不能使用new运算符实例化一个NumberFormat对象，只能直接使用类名调用一个特殊的静态方法来得到一个对象。
  比如： NumberFormat类中的getInstance()方法返回当前默认语言环境的默认数值格式，然后使用格式对象来调用format()方法，将参数按相应的模式格式化后作为字符串返回。
  String myString = NumberFormat.getInstance().format(myNumber);
  和NumberFormat类不一样，DecimalFormat类按惯例使用new运算符来实例化对象。它的构造方法要带一个String类型的参数，这个参数表示格式化处理模式。

第四节、处理异常
  Java语言把程序运行中可能遇到的错误分为两类，一类是非致命性的，通过某种修正后程序还能继续执行。这类错误称为异常(Exception)。如打开一个文件时，发现文件不存在。又比如说除0溢出、数组越界等。这一类错误可以借助程序员的处理来恢复。
  另一类是致命性的，即程序遇到了非常严重的不正常状态，不能简单地恢复执行，这就是错误。比如程序运行过程中内存耗尽。异常处理要考虑的问题包括：如何处理异常？把异常交给谁去处理？程序又该如何从异常中恢复？
  
  1. 异常及处理机制：
  为了解决异常问题，Java提供了异常处理机制，预定义了一个Exception类。当程序中发生异常时，通常不是简单地结束程序，而是转去执行某段特殊代码来处理这个异常，设法恢复程序继续执行。但是如果程序遇到错误时，往往不能从中恢复，因此最好的办法是让程序中断执行。
  在一个方法的运行过程中，如果发生了异常，称程序产生了一个异常事件，相应地生成异常对象。该对象可能由正在运行的方法产生，也可能由JVM生成。这个对象中包含了该异常必要的详细信息,包括所发生的异常事件的类型及异常发生时程序的运行状态.
  生成的异常对象传递给Java运行时系统,运行时系统寻找相应的代码来处理这个异常. 生成异常对象并把它提交给运行时系统的这一过程称为抛出(Throw)一个异常.
  Java运行时系统从生成对象的代码块开始进行回溯,沿方法的调用栈逐层回溯,寻找相应的处理代码,直到找到包含相应异常处理的方法为止,并把异常对象交给该方法处理. 这一过程称为捕获(Catch). 当发现并相应异常时,就是处理(Handle)了异常。
  简而言之，发现错误的代码可以“抛出”一个异常，程序员可以“捕获”该异常，如果可能则“处理”它，然后恢复程序的执行。

  2. 异常分类：
  Java语言在所有的预设包中都定义了异常类和错误类。Exception类是所有异常类的父类，Error类是所有错误类的父类，这两个类同时又是Throwable类的子类。虽然异常属于不同的类，但所有这些类都是标准类Throwable的后代。
  Throwable在Java类库中，不需要import语句就可以使用。异常分为三种：{ 1.受检异常，必须被处理。 2.运行时异常，不需要处理。 3.错误，不需要处理。}
    1.受检异常(Checked Exception)是程序执行期间发生的严重事件的后果。例如，如果程序从磁盘中读入数据，而系统找不到含有数据的文件，将会发生受检异常。这个异常所属类的类名是FileNotFoundException。发生错误的原因可能是文件丢失等等，写的好的程序通常都会预见这种问题并处理。
    Java类库中的所有类都是使用名字来描述异常原因的。这些类表示受检异常: ClassNotFoundException / FileNotFoundException / IOException / NoSuchMethodException 及 WriteAbortedException.
  
    2.运行时异常(Runtime Exception)通常是程序逻辑错误的结果。例如，数组下标越界导致ArrayIndexOutOfBounds异常。被0除导致ArithmeticException异常。虽然可以添加代码来处理运行时异常，但一般只需要修改程序中的错误即可。
    运行时异常的所有类都是类RuntimeException的子类，它是Exception的后代。
    Java类库中的这些类表示运行时异常: ArithmeticException /  ArrayIndexOutOfBoundsException / ClassCastException / EmptyStackException / IllegalArgumentException / IllegalStateException / indexOutofBoundsException / NoSuchElementException / NullPointerException 和 UnsupportedOperationException

    3.错误(Error)是标准类Error或其后代类的一个对象, Error是Throwable的后代。一般地，错误是指发生了不正确的情况，如内存溢出。这些情况都比较严重，一般程序很难处理。所以，即使处理错误是合法的，一般也不需要处理它们。
    运行时异常和错误称为不检异常(Unchecked Exception)。
  有些异常类在使用时必须要引入。例如，当在程序中使用IOException时，必须要使用import java.io.IOException;

  3.处理异常：
  当发生异常时，程序通常会中断执行，并输出一条信息。对所发生的异常进行处理的就是异常处理。异常处理的重要性在于程序不但能发现异常，还要能捕获异常。对于可能引发受检异常的方法，有两种选择：在方法内处理异常，或时告诉方法的调用者来处理。
  比如，方法method1 调用 method2，method2又调用method3，进而method3又调用method4。在方法method4中如果出现异常，则在调用栈中的任何一个方法都可以捕获并处理这个异常。
  要处理异常，必须先标出可能引起异常的Java语句，还必须决定要找哪个异常。处理异常的代码含有两段。第一段try块含有可能抛出异常的语句。第二段含有一个或多个catch块。每个catch块含有捕获及处理某中类型异常的代码。
  catch(IOException e)标识符 e 称为catch块参数，它表示catch块将要处理IOException对象。参数e表示一个实际的异常。作为一个对象，每个异常都有存取方法getMessage()，它返回抛出异常时创建的描述字符串。通过显示这个字符串可知所发生异常的性质。
  catch块执行完毕，执行它后面的语句。但是如果问题很严重，则catch块可以调用exit方法来中止程序，如 System.exit(0); 赋给函数System.exit的参数0，表示虽然遇到了一个严重问题，但程序是正常结束的。
  单一一个try块中的语句，可能会抛出不同类型异常中的任意一个。在这样的try块后的catch块需要能捕获多个类的异常。为此，可以在try块后写多个catch块。当抛出一个异常时，为了能使所写的catch块真正捕获到相应的异常，catch块出现的次序很重要。程序的执行流程进入到其参数与异常类型相匹配的第一个catch块 ———— 按照出现的次序
  例如，下列的catch块次序不好，因为用于FileNotFoundException的catch块永远不会被执行：
  catch(IOException e) { .... } 
  catch(FileNotFoundException e) { .... }
  按照这个次序，任何I/O异常都被第一个catch块捕获。因为FileNotFoundException 派生于IOException，所以FileNotFoundException异常是IOException异常的一种，将与第一个catch块的参数相匹配。幸运的是，编译程序可能会对这样的次序给出警告信息。
  正确的次序是：
  catch(FileNotFoundException e) { .... } 
  catch(IOException e) { .... }  //处理所有其他的IOException
  因为受检异常和运行时异常的类都以Exception为祖先，故应避免在catch中使用Exception，而是尽可能地捕获具体的异常，且先捕获最具体的。
  try-catch的语法格式如下：
  try {
    //可能抛出异常的代码
  } catch (异常类型1 e) {
    //抛出异常类型1时要执行的代码，可能包含：
    System.out.println(e.getMessage());
  } catch (异常类型2 e) {
    //抛出异常类型2时要执行的代码，可能包含：
    System.out.println(e.getMessage());
  } finally {
    // 必须执行的代码
  }
  其中，异常类型1、异常类型2是产生的异常类型。根据发生异常所属的类，找到相应的catch语句，然后执行其中的语句。尽量避免在try块或catch块中再嵌套try-catch块；
  不论是否捕获异常，都要执行finally后的语句。一般地，为了统一处理程序出口，可将要处理的内容放到finally后的代码段中。
  try后的大括号中的代码称为保护代码。如果在保护代码内执行了System.exit()方法，将不在执行finally后面的语句，这是不执行finally后面语句的唯一一种可能。

  4.公共异常：
  为了方便处理异常，Java预定义了一些常见的异常，下面列举几个常用到的异常。
  1.ArithmeticException
  整数除法中，如果除数为0，则发生异常，如这个表达式将引发ArithmeticException异常：int i = 12/0;
  2.NullPointerException
  如果一个对象还没有实例化，那么访问该对象或调用它的方法将导致NullPointerException异常。例如：
  image im [] = new image[4];
  System.out.println(im[0].toString());
  第一行创建了有4个元素的数组im，每个元素是image类型，系统为其进行初始化，每个元素的值为null，表明它还没有指向任何实例。第二行要访问im[0]，由于访问的是还没有进行实例化的空引用，因此会导致NullPointerException。
  3.NegativeArraySizeException
  按常规，数组的元素个数应是一个大于等于0的整数。创建数组时，如果元素个数是负数，则会引发NegativeArraySizeException异常。
  4.ArrayIndexOutOfBoundsException
  Java把数组看作是对象，并用length变量记录数组的大小。访问数组元素时，运行时环境根据length值检查下标的大小。如果数组下标越界，则将导致ArrayIndexOutOfBoundsException异常。

  5.抛出异常：
  Java要求如果一个方法确实引发了一个异常(当然Error或RuntimeException两类错误除外)，那么在方法中必须写明相应的处理代码。
  处理异常有两种方法。一种是try块和catch块，捕获到所发生的异常类，并进行相应的处理。当然，catch块可以为空，表示对发生的异常不进行处理。
  另一种方法是，不在当前方法内处理异常，而是把异常抛出到调用方法中。当不能使用合理的方式来解决不正常或意外事件的情形下，才抛出异常。
  方法内执行throw语句时会抛出一个异常，一般形式如：throw exception_object;
  throw语句创建了一个异常对象 exception_object ，如： throw new IOException(); 这个语句创建类IOException的一个新对象并抛出它。抛出异常类型时也应该尽可能地具体。
    相应地，在说明方法时，要使用这个格式： 访问权限修饰符 返回值类型 方法名(参数列表) throws 异常列表
    紧接在关键字throws后面的是该方法内可能发生且不进行处理的所有异常列表。各异常之间用逗号分隔。例如：public void troubleSome() throws IOException
    一般地，如果一个方法引发了一个异常，而它自己又不处理，就要由调用者方法进行处理。如果方法内含有一个抛出异常的throw语句，则要在方法头添加一个throws子句，而不是在方法体内捕获异常。一般地，抛出异常及捕获异常应该在不同的方法内。
    在方法头中用Java保留字throws来声明这个方法可能抛出的异常；在方法体中用保留字throw实际抛出一个异常。  注意，这两个保留字不要混淆；

第三章小结：包是Java大的独特概念，与此相关的语句包括package语句和import语句。
本章详细介绍了各主要语句的语法格式，使用它们可以编写出基本的程序。此外还介绍了简单的输入/输出语句。
要编写稳定性强的程序，必须对可鞥出现的错误进行处理。Java提供了异常处理机制，本章详细介绍了异常处理的概念及处理机制，包括try、catch、finally、throw 和 throws 的使用方法。介绍了预定义的若干异常，以及编写程序时要注意的事项。


第四章 面向对象程序设计：
第一节、类和对象：
  1.类的定义：
  类的定义也称为类的声明。类中含有两部分元素，分别是数据成员变量和成员方法。类定义的一般格式如下：
  修饰符 class 类名 [extends 父类名] {
    修饰符 类型 成员变量1;
    修饰符 类型 成员变量2;
    ......
    修饰符 类型 成员方法1(参数列表) {
      方法体
    }
    修饰服 类型 成员方法2(参数列表) {
      方法体
    }
    ......
  }
  其中,class是关键字,表明其后定义是一个类. 含有class这一行称为类头,后面大括号括住的部分称为类体. class前的修饰符可以有多个,用来限定所定义的类的使用方式. 类名是用户为该类所起的名字,它必须是一个合法的标识符,并尽量遵从命名约定.
  extends是继承关键子. 如果所定义的类是从某个父类派生而来,那么,父类的名字要写在extends之后。 类定义中的数据成员变量可以有多个。成员变量前面的类型是该变量的类型；类中的成员方法也可以有很多个，其前面的类型是该方法返回值的类型。如果没有返回值，则写void。方法体是要执行的真正语句。
  在方法体中还可以定义该方法内使用的局部变量，这些局部变量只在该方法内有效。方法的参数列表中可以含有0个或多个参数，每个参数的前面要指明该参数的类型。 类定义中的修饰符是访问权限修饰符，包括public,private和protected, 也可以不写，表示是默认修饰符。
  它们既可以用来修饰类，又可以修饰类中的成员，修饰符决定所修饰成员在程序运行时被访问的方式。具体来说，用public修饰的成员表示是公有的，也就是它可以被其他任何对象访问。类中限定为private的成员只能被这个类本身访问，在类外不可见。用protected修饰的成员是受保护的，只可以被同一个包及其子类的实例的对象访问。
  如果不写任何修饰符，则表明是默认的，相应的成员可以被所在包中的各类访问。
  关于类定义，总结如下：
  ①类定义中，类头与类体是放在一起保存的，整个类必须在一个文件中，因此有时源文件会很大。
  ②源文件名必须根据文件中的公有类名来定义，并且要区分大小写。
  ③类定义中可以指明父类，也可以不指明。若没有指明是从哪个类派生而来，则表明是从默认的父类Object派生而来。实际上，Object是Java所有类的直接或间接父类。Java中除Object之外的所有类均有一个且只有一个父类。Object是唯一没有父类的类。
  ④class定义的大括号之后没有分隔符 ";" 

  2.构造方法：
  构造方法是一类特殊的方法，有特殊的功能。构造方法的名字与类名相同，没有返回值，在创建对象实例时通过new运算符自动调用。同时为了便于创建实例，一个类可以有多个具有不同参数列表的构造方法，即构造方法可以重载。事实上，不论是系统提供的标准类，还是用户定义的类，往往都含有多个构造方法。
  例如：
  public class Xyz {
    int x;   // 成员变量
    public Xyz() { x = 0; } // 参数列表为空的构造方法
    public Xyz(int i) { x = i; } // 第一个参数的构造方法
  }
  在类Xyz中定义了两个构造方法，第一个方法的参数列表是空的，第二个方法带有一个int类型参数。在创建Xyz的实例时，可以使用下列两种形式：
  Xyz obj =  new Xyz(); // 使用第一个构造方法
  Xyz obj2 = new Xyz(5); // 使用第二个构造方法
  构造方法不能说明为native，abstract，synchronized或final类型，通常说明为public类型。构造方法不能从父类继承。另外，构造方法没有返回值。一般来说，构造方法应该为所有的成员变量赋初始值，成员变量的值亦称为对象的属性值。
  默认的构造方法：每个类必须至少有一个构造方法。如果程序员没有为类定义构造方法，系统就会自动为该类生成一个默认的构造方法。默认构造方法的参数列表及方法体均为空，所生成的对象的各属性也为零或空。如果类定义中已经含有一个或多个构造方法，则系统不会再自动生成默认的构造方法了。
  构造方法重载： 在进行对象实例化时可能会遇到许多不同情况，于是要求针对所给定的不同的参数，调用不同的构造方法。这时，可以通过在一个类中同时定义若干个构造方法，亦即对构造方法进行重载来实现。
  有些构造方法中会有重复的代码，或者一个构造函数可能包含另一个构造方法中的全部代码，为了简化代码，可以在其中一个构造方法中引用另一个构造方法。可以使用关键字this来指代本类中的其他构造方法。
  例如：构造方法的重载及引用
  public class Student {
    String name;
    int age;
    public Student(String s, int n) {  // 构造方法1
      name = s;
      age = n;
    }
    public Student(String s) { // 构造方法2
      this(s , 20);
    }
    public Student() { // 构造方法3
      this("Unknown");
    }
  }
  在上面的示例中，第三个构造方法中没有任何参数，它调用this("Unknown"),实际上是把控制权转给了只带一个字符串参数的第二个构造方法，并为其提供了所需的字符串参数值"Unknown"。而第二个构造方法中，则通过调用this(s , 20),把控制权转给第一个构造方法，并为其提供了字符串参数"Unknown"和int类型参数的值20。
  this引用： this除了可以用在构造方法中之外，还可以用来指明要操作的对象本身。

  3.对象的创建和初始化
  实际上，类的定义相当于一个“模子”，声明一个个类类型变量的过程就像是拿着模子复制一个个的副本，程序中使用的就是这样的一个个对象。
  以上面的Student类为例，现在可以声明Student类型的变量：Student myObj; 
  声明变量后，在内存中为其建立了一个引用，此时它不指向任何内存空间。对象的引用也称为对象的句柄。之后需要使用 new 申请相应的内存空间，内存空间的大小依class的定义而定，并将该段内存的首地址赋给刚才建立的引用。
  换句话说，用class类型声明的变量并不是数据本身，而只是对数据的引用，要用new来进一步创建类的实例或叫对象本身。比如： myObj = new Student(); 调用 new 为新对象分配空间，就是要调用类的构造方法。
  在Java中，使用构造方法是生成实例对象的唯一途径。这个过程称为对象的实例化。说明一个引用变量仅仅只是预定了变量的存储空间，此时并没有相应的地址空间给实例使用。必须进行对象实例化之后，才有真正的实例出现。在调用new时，是否带有参数、带多少个、各是什么类型的参数，要视具体的构造方法而定。系统根据所带参数的个数和类型，调用相应的构造方法。
  


  

  


  

